Abstract Contract FullMath() extends OracleErrors() {
  const Resolution = 112

  pub fn fullMul(x: U256, y: U256) -> (U256, U256) {
    let mm = mulModN!(x, y, u256Max!())
    let l = x |*| y
    let mut h = mm |-| l
    if (mm < l) {
      h = h |-| 1
    }
    return l, h
  }

  // from: https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol
  pub fn mulDiv(a: U256, b: U256, mut denominator: U256) -> U256 {
    assert!(denominator != 0, ErrorCodes.DivByZero)
    let (mut prod0, mut prod1) = fullMul(a, b)
    if (prod1 == 0) {
      return prod0 / denominator
    }

    assert!(denominator > prod1, ErrorCodes.FullDivOverflow)

    let remainder = mulModN!(a, b, denominator)
    if (remainder > prod0) {
      prod1 = prod1 |-| 1
    }
    prod0 = prod0 |-| remainder

    let mut twos = (0 |-| denominator) & denominator
    denominator = denominator / twos
    prod0 = prod0 / twos
    twos = ((0 |-| twos) / twos) |+| 1
    prod0 = prod0 | (prod1 |*| twos)

    let mut inv = (3 |*| denominator) ^ 2
    inv = inv |*| (2 |-| (denominator |*| inv))
    inv = inv |*| (2 |-| (denominator |*| inv))
    inv = inv |*| (2 |-| (denominator |*| inv))
    inv = inv |*| (2 |-| (denominator |*| inv))
    inv = inv |*| (2 |-| (denominator |*| inv))
    inv = inv |*| (2 |-| (denominator |*| inv))
    return prod0 |*| inv
  }

  pub fn fraction(numerator: U256, denominator: U256) -> U256 {
    assert!(denominator != 0, ErrorCodes.DivByZero)
    if (numerator == 0) {
      return 0
    }
    let result = if (numerator < (1 << 144)) (numerator << Resolution) / denominator else mulDiv(numerator, 1 << Resolution, denominator)
    assert!(result < (1 << 224), ErrorCodes.FractionOverflow)
    return result
  }
}
