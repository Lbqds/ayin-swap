import "std/fungible_token_interface"

Contract LiquidStaking(
    // Nit: ayin: AyinToken, we can use `tokenId!(ayin)` to get the token id of ayin, and use `contractId!(ayin)` to get the contract id of ayin, both `tokenId!` and contractId!` will not bring additional gas costs, and it can make the code clear.
    tokenId: ByteVec,
    symbol: ByteVec,
    name: ByteVec,
    mut inflationPool: U256,
    mut inflationRate: U256,
    mut gainPerMillisecond: U256, // Percentage of rewardPool to be paid as a reward each millisecond where 1e18 is 100% of the pool
    mut updatedAt: U256,
    mut currentXTokenPrice: U256,
    mut rewardPool: U256,
    mut totalSupply: U256,
    mut owner_: Address,
    mut paused_: Bool
) extends Pauseable(owner_, paused_) implements IFungibleToken {
    event Mint(sender: Address, amount: U256, newSupply: U256)
    event Burn(sender: Address, amount: U256, newSupply: U256)
    event PriceChanged(newPrice: U256)

    fn getInflationPerMillisecond() -> U256 {
        // Nit: return inflationRate * 1e18 / totalSupply, we can save the gas consumption of store and load, currently the compiler does not have such optimization
        let inflation = inflationRate * 1e18 / totalSupply

        return inflation
    }

    // Reward paid per 1 xToken
    pub fn getCurrentRewardPerMillisecond() -> U256 {
        // Nit: return gainPerMillisecond * rewardPool / totalSupply
        let rewardPerMillisecond = gainPerMillisecond * rewardPool / totalSupply

        return rewardPerMillisecond
    }

    fn getCurrentReward() -> U256 {
        if (totalSupply == 0) {
            return 0
        }

        let rewardPerMillisecond = getCurrentRewardPerMillisecond()
        let elapsed = blockTimeStamp!() - updatedAt
        let projectedReward = rewardPerMillisecond * elapsed
        // Nit: return if (projectedReward > rewardPool) rewardPool else projectedReward
        let reward = if (projectedReward > rewardPool) rewardPool else projectedReward

        return reward
    }

    fn getCurrentInflation() -> U256 {
        if (totalSupply == 0) {
            return 0
        }

        let inflationPerMillisecond = getInflationPerMillisecond()
        let elapsed = blockTimeStamp!() - updatedAt
        let projectedInflation = inflationPerMillisecond * elapsed

        // Nit: return if (projectedInflation > inflationPool) inflationPool else projectedInflation
        let inflation = if (projectedInflation > inflationPool) inflationPool else projectedInflation

        return inflation
    }

    pub fn getCurrentPrice() -> U256 {
        if (totalSupply == 0) {
            return currentXTokenPrice
        }

        let reward = getCurrentReward()
        let inflation = getCurrentInflation()

        // Nit: return currentXTokenPrice + reward + inflation
        let currentPrice = currentXTokenPrice + reward + inflation
        return currentPrice
    }

    @using(updateFields = true)
    fn updatePrice() -> () {
        let newPrice = getCurrentPrice()
        let reward = getCurrentReward()
        let inflation = getCurrentInflation()

        if (rewardPool <= reward) {
            rewardPool = 0
        } else {
            rewardPool = rewardPool - reward
        }

        if (inflationPool <= inflation) {
            inflationPool = 0
        } else {
            inflationPool = inflationPool - inflation
        }
        
        currentXTokenPrice = newPrice
        updatedAt = blockTimeStamp!()

        emit PriceChanged(currentXTokenPrice)
    }

    @using(assetsInContract = true, preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn mint(amount: U256) -> () {
        whenNotPaused()
        updatePrice()
        let xTokenAmount = amount * 1e18 / currentXTokenPrice
        
        transferTokenToSelf!(callerAddress!(), tokenId, amount)
        transferTokenFromSelf!(callerAddress!(), selfTokenId!(), xTokenAmount)

        totalSupply = totalSupply + xTokenAmount

        emit Mint(callerAddress!(), xTokenAmount, totalSupply)
    }

    @using(assetsInContract = true, preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn burn(xTokenAmount: U256) -> () {
        whenNotPaused()
        updatePrice()
        let tokenAmount = xTokenAmount * currentXTokenPrice / 1e18

        transferTokenToSelf!(callerAddress!(), selfTokenId!(), xTokenAmount)
        transferTokenFromSelf!(callerAddress!(), tokenId, tokenAmount)

        totalSupply = totalSupply - xTokenAmount

        emit Burn(callerAddress!(), xTokenAmount, totalSupply)
    }

    @using(assetsInContract = true, preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn topUpRewards(amount: U256) -> () {
        whenNotPaused()
        updatePrice()

        transferTokenToSelf!(callerAddress!(), tokenId, amount)

        rewardPool = rewardPool + amount
    }

    @using(updateFields = true)
    pub fn setGainPerMillisecond(newGainPerMillisecond: U256) -> () {
        onlyOwner(callerAddress!())
        updatePrice()

        gainPerMillisecond = newGainPerMillisecond
    }

    @using(updateFields = true)
    pub fn setInflationRate(newInflationRate: U256) -> () {
        onlyOwner(callerAddress!())
        updatePrice()

        inflationRate = newInflationRate
    }

    pub fn getTokenId() -> ByteVec {
        return tokenId
    }

    pub fn getSymbol() -> ByteVec {
        return symbol
    }

    pub fn getName() -> ByteVec {
        return name
    }

    pub fn getDecimals() -> U256 {
        return 18
    }

    pub fn getTotalSupply() -> U256 {
        return totalSupply
    }
}
